package com.bingbank.authService.service;

import com.bingbank.authService.dto.JwtAuthResponse;
import com.bingbank.authService.dto.LoginRequest;
import com.bingbank.authService.dto.RegisterRequest;
import com.bingbank.authService.dto.VerifyOTPRequest;
import com.bingbank.authService.model.Customer;
import com.bingbank.authService.repository.CustomerRepository;
import com.bingbank.authService.security.JwtTokenProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import jakarta.mail.MessagingException;
import java.util.Optional;

@Service
public class AuthService {

    private static final String LOGIN_PURPOSE = "LOGIN";

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtTokenProvider tokenProvider;

    @Autowired
    private OTPService otpService;

    public ResponseEntity<?> login(LoginRequest loginRequest) {
        try {
            // Authenticate with username and password
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getEmail(),
                            loginRequest.getPassword()
                    )
            );

            SecurityContextHolder.getContext().setAuthentication(authentication);

            // Get customer details
            Customer customer = customerRepository.findByEmail(loginRequest.getEmail())
                    .orElseThrow(() -> new RuntimeException("User not found"));

            // Check if 2FA is enabled
            if (customer.getTwoFactorEnabled()) {
                // Generate and send OTP
                try {
                    otpService.generateAndSendOTP(customer, LOGIN_PURPOSE);
                    
                    // Return response indicating OTP is required
                    return ResponseEntity.ok(JwtAuthResponse.builder()
                            .otpRequired(true)
                            .email(customer.getEmail())
                            .customerId(customer.getCustomerId())
                            .firstName(customer.getFirstName())
                            .lastName(customer.getLastName())
                            .build());
                } catch (MessagingException e) {
                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                            .body("Failed to send OTP email");
                }
            } else {
                // 2FA not enabled, generate token
                String token = tokenProvider.generateToken(authentication);

                return ResponseEntity.ok(JwtAuthResponse.builder()
                        .accessToken(token)
                        .tokenType("Bearer")
                        .email(customer.getEmail())
                        .customerId(customer.getCustomerId())
                        .firstName(customer.getFirstName())
                        .lastName(customer.getLastName())
                        .otpRequired(false)
                        .build());
            }
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body("Invalid email or password");
        }
    }

    public ResponseEntity<?> verifyOTP(VerifyOTPRequest verifyOTPRequest) {
        try {
            // Find customer by email
            Customer customer = customerRepository.findByEmail(verifyOTPRequest.getEmail())
                    .orElseThrow(() -> new RuntimeException("User not found"));

            // Validate OTP
            boolean isValid = otpService.validateOTP(customer, verifyOTPRequest.getOtp(), LOGIN_PURPOSE);

            if (isValid) {
                // Generate JWT token
                String token = tokenProvider.generateToken(customer.getEmail());

                return ResponseEntity.ok(JwtAuthResponse.builder()
                        .accessToken(token)
                        .tokenType("Bearer")
                        .email(customer.getEmail())
                        .customerId(customer.getCustomerId())
                        .firstName(customer.getFirstName())
                        .lastName(customer.getLastName())
                        .otpRequired(false)
                        .build());
            } else {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body("Invalid or expired OTP");
            }
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error verifying OTP: " + e.getMessage());
        }
    }

    public ResponseEntity<?> register(RegisterRequest registerRequest) {
        // Check if email exists
        if (customerRepository.existsByEmail(registerRequest.getEmail())) {
            return ResponseEntity.badRequest().body("Email already exists");
        }

        // Create new customer
        Customer customer = new Customer();
        customer.setFirstName(registerRequest.getFirstName());
        customer.setLastName(registerRequest.getLastName());
        customer.setEmail(registerRequest.getEmail());
        customer.setPassword(passwordEncoder.encode(registerRequest.getPassword()));
        customer.setAge(registerRequest.getAge());
        customer.setGender(registerRequest.getGender());
        customer.setAddress(registerRequest.getAddress());
        customer.setMobile(registerRequest.getMobile());
        customer.setTwoFactorEnabled(registerRequest.getTwoFactorEnabled());

        customerRepository.save(customer);

        return ResponseEntity.status(HttpStatus.CREATED)
                .body("Customer registered successfully");
    }

    public ResponseEntity<?> enable2FA(Long customerId, boolean enable) {
        try {
            Customer customer = customerRepository.findById(customerId)
                    .orElseThrow(() -> new RuntimeException("Customer not found"));
            
            customer.setTwoFactorEnabled(enable);
            customerRepository.save(customer);
            
            return ResponseEntity.ok("Two-factor authentication " + (enable ? "enabled" : "disabled") + " successfully");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error updating 2FA settings: " + e.getMessage());
        }
    }
}